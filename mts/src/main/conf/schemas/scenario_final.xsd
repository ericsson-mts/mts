<?xml version="1.0" encoding="UTF-8"?>

<!--
    Document   : dictionary.xsd
    Created on : 28 mai 2007, 21:14
    Author     : Gege
    Description:
        Purpose of XML Schema document follows.
-->

<xs:schema  xmlns:xs="http://www.w3.org/2001/XMLSchema"
    xmlns:SOAP-ENV="http://schemas.xmlsoap.org/soap/envelope/"
    elementFormDefault="qualified">

    <xs:element name="scenario" type="scenarioType" />

    <xs:complexType name="scenarioType">
        <xs:complexContent>
            <xs:extension base="doType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded" >
                    <xs:element name="finally" type="doType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="doType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded" >
                    <!--&list_core_do;-->
                    <xs:element name="pause"               type="pauseType"               minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="exit"                type="exitType"                minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="system"              type="systemType"              minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="semaphore"           type="semaphoreType"           minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="sqlQuery"            type="sqlQueryType"            minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="if"                  type="ifType"                  minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="switch"              type="switchType"              minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"                type="testType"                minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"                 type="conditionType"           minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"                  type="conditionType"           minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"                 type="conditionType"           minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="parameter"           type="parameterType"           minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="while"               type="whileType"               minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="try"                 type="tryType"                 minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="receiveMessage"      type="receiveMessageType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="log"                 type="logType"                 minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="stats"               type="statsType"               minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="goto"           	   type="gotoType"                minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="label"               type="labelType"               minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="for"                 type="forType"                 minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="function"            type="functionType"            minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="call"                type="callType"                minOccurs="0" maxOccurs="unbounded" />

                    <!--&list_1;-->
                    <!-- liste des methodes pour la pile aaa -->           

                    <xs:element name="sendMessageDIAMETER"      type="sendMessageDIAMETERType"       minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the DIAMETER protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageDIAMETER"   type="receiveMessageDIAMETERType"    minOccurs="0" maxOccurs="unbounded" >
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the DIAMETER protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="createListenpointDIAMETER" type="createListenpointDIAMETERType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the DIAMETER protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="removeListenpointDIAMETER" type="removeListenpointDIAMETERType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the DIAMETER protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>	
                    <xs:element name="createProbeDIAMETER" type="createProbeDIAMETERType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start the probe to capture for the DIAMETER protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="removeProbeDIAMETER" type="removeProbeDIAMETERType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop the probe to capture for the DIAMETER protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="openChannelDIAMETER"  type="openChannelDIAMETERType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the DIAMETER protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelDIAMETER" type="closeChannelDIAMETERType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the DIAMETER protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_2;-->
                    <!-- liste des methodes pour la pile sip -->   

                    <xs:element name="sendMessageSIP" type="sendMessageSIPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the SIP protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="receiveMessageSIP" type="receiveMessageSIPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the SIP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="createListenpointSIP" type="createListenpointSIPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the SIP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="removeListenpointSIP" type="removeListenpointSIPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the SIP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="createProbeSIP" type="createProbeSIPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start the probe to capture for the SIP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="removeProbeSIP" type="removeProbeSIPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop the probe to capture for the SIP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_3;-->
                    <!-- liste des methodes pour la pile rtp -->

                    <xs:element name="sendMessageRTP"           type="sendMessageRTPType"     minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the RTP protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
                        </xs:annotation>
                    </xs:element>	
                    <xs:element name="receiveMessageRTP"        type="receiveMessageRTPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the RTP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="createListenpointRTP"     type="createListenpointRTPType"     minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the RTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="removeListenpointRTP"     type="removeListenpointRTPType"    minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the RTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>				
                    <xs:element name="createProbeRTP" type="createProbeRTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start the probe to capture for the RTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="removeProbeRTP" type="removeProbeRTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop the probe to capture for the RTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageRTPFLOW"       type="sendMessageRTPFLOWType"     minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the RTPFLOW protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
                        </xs:annotation>
                    </xs:element>		
                    <xs:element name="receiveMessageRTPFLOW"    type="receiveMessageRTPFLOWType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the RTPFLOW protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="createListenpointRTPFLOW"     type="createListenpointRTPFLOWType"     minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the RTPFLOW protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="removeListenpointRTPFLOW"     type="removeListenpointRTPFLOWType"    minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the RTPFLOW protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>				
                    <xs:element name="createProbeRTPFLOW" type="createProbeRTPFLOWType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start the probe to capture for the RTPFLOW protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="removeProbeRTPFLOW" type="removeProbeRTPFLOWType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop the probe to capture for the RTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>


                    <!--&list_4;-->
                    <!-- liste des methodes pour la pile http -->

                    <xs:element name="openChannelHTTP"  type="openChannelHTTPType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the HTTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelHTTP" type="closeChannelHTTPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the HTTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageHTTP"     type="sendMessageHTTPType"      minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the HTTP protocol using a channel or with the transactionId (user defined).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageHTTP"  type="receiveMessageHTTPType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the HTTP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_6;-->
                    <!-- liste des methodes pour la pile tcp -->


                    <xs:element name="openChannelTCP" type="openChannelTCPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the TCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelTCP" type="closeChannelTCPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the TCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointTCP"     type="createListenpointTCPType"     minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the TCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointTCP"     type="removeListenpointTCPType"     minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the TCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageTCP" type="sendMessageTCPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the TCP protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageTCP" type="receiveMessageTCPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the TCP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_7;-->
                    <!-- liste des methodes pour la pile udp -->


                    <xs:element name="openChannelUDP" type="openChannelUDPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the UDP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelUDP" type="closeChannelUDPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the UDP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointUDP" type="createListenpointUDPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the UDP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointUDP" type="removeListenpointUDPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the UDP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageUDP" type="sendMessageUDPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the UDP protocol a listenpoint (user defined or the default one).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageUDP" type="receiveMessageUDPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the UDP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_8;-->
                    <!-- liste des methodes pour la pile sctp -->


                    <xs:element name="openChannelSCTP" type="openChannelSCTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the SCTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelSCTP" type="closeChannelSCTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the SCTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointSCTP" type="createListenpointSCTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the SCTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointSCTP" type="removeListenpointSCTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the SCTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageSCTP" type="sendMessageSCTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the SCTP protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageSCTP" type="receiveMessageSCTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the SCTP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>


                    <!--&list_9;-->
                    <!-- liste des methodes pour la pile Radius -->

                    <xs:element name="createListenpointRADIUS" type="createListenpointRADIUSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the RADIUS protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="removeListenpointRADIUS" type="removeListenpointRADIUSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the RADIUS protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageRADIUS" type="sendMessageRADIUSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the RADIUS protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="receiveMessageRADIUS" type="receiveMessageRADIUSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the RADIUS protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>                    

                    <!--&list_10;-->
                    <!-- liste des methodes pour la pile smtp -->                    

                    <xs:element name="openChannelSMTP" type="openChannelSMTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the SMTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelSMTP" type="closeChannelSMTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the SMTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointSMTP" type="createListenpointSMTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the SMTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointSMTP" type="removeListenpointSMTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the SMTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageSMTP" type="sendMessageSMTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the SMTP protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageSMTP" type="receiveMessageSMTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the SMTP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_11;-->
                    <!-- liste des methodes pour la pile rtsp -->

                    <xs:element name="openChannelRTSP"          type="openChannelRTSPType"          minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the RTSP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelRTSP"         type="closeChannelRTSPType"         minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the RTSP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointRTSP"    type="createListenpointRTSPType"    minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the RTSP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointRTSP"    type="removeListenpointRTSPType"    minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the RTSP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageRTSP"          type="sendMessageRTSPType"          minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the RTSP protocol using a channel or with the transactionId (user defined).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageRTSP"       type="receiveMessageRTSPType"       minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the RTSP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_12;-->
                    <!-- liste des methodes pour la pile imap -->

                    <xs:element name="openChannelIMAP"   type="openChannelIMAPType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the IMAP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelIMAP"  type="closeChannelIMAPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the IMAP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointIMAP"  type="createListenpointIMAPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the IMAP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointIMAP"  type="removeListenpointIMAPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the IMAP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageIMAP"      type="sendMessageIMAPType"      minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the IMAP protocol using a channel or with the transactionId (user defined).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageIMAP"   type="receiveMessageIMAPType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the IMAP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_13;-->
                    <!-- liste des methodes pour la pile POP -->

                    <xs:element name="openChannelPOP"   type="openChannelPOPType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the POP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelPOP"  type="closeChannelPOPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the POP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointPOP"  type="createListenpointPOPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the POP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointPOP"  type="removeListenpointPOPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the POP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessagePOP"      type="sendMessagePOPType"      minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the POP protocol using a channel or with the transactionId (user defined).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessagePOP"   type="receiveMessagePOPType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the POP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_14;-->
                    <!-- liste des methodes pour la pile SMPP -->

                    <xs:element name="openChannelSMPP"   type="openChannelSMPPType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the SMPP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelSMPP"  type="closeChannelSMPPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the SMPP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointSMPP"  type="createListenpointSMPPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the SMPP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointSMPP"  type="removeListenpointSMPPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the SMPP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageSMPP"      type="sendMessageSMPPType"      minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the SMPP protocol using a channel or with the transactionId (user defined).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageSMPP"   type="receiveMessageSMPPType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the SMPP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_15;-->
                    <!-- liste des methodes pour la pile UCP -->

                    <xs:element name="openChannelUCP"   type="openChannelUCPType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the UCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelUCP"  type="closeChannelUCPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the UCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointUCP"  type="createListenpointUCPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the UCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointUCP"  type="removeListenpointUCPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the UCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageUCP"      type="sendMessageUCPType"      minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the UCP protocol using a channel or with the transactionId (user defined).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageUCP"   type="receiveMessageUCPType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the UCP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_16;-->
                    <!-- liste des methodes pour la pile SIGTRAN -->

                    <xs:element name="openChannelSIGTRAN"   type="openChannelSIGTRANType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the SIGTRAN protocol.</xs:documentation>
                        </xs:annotation> 
                    </xs:element>

                    <xs:element name="closeChannelSIGTRAN"  type="closeChannelSIGTRANType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the SIGTRAN protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointSIGTRAN"  type="createListenpointSIGTRANType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the SIGTRAN protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointSIGTRAN"  type="removeListenpointSIGTRANType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the SIGTRAN protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageSIGTRAN"      type="sendMessageSIGTRANType"      minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the SIGTRAN protocol using a channel or with the transactionId (user defined).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageSIGTRAN"   type="receiveMessageSIGTRANType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the SIGTRAN protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_17;-->
                    <!-- liste des methodes pour la pile tls -->

                    <xs:element name="openChannelTLS" type="openChannelTLSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the TLS protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelTLS" type="closeChannelTLSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the TLS protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointTLS"     type="createListenpointTLSType"     minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the TLS protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointTLS"     type="removeListenpointTLSType"     minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the TLS protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageTLS" type="sendMessageTLSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the TLS protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageTLS" type="receiveMessageTLSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the TLS protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_18;-->
                    <!-- liste des methodes pour la pile h248 -->

                    <xs:element name="openChannelH248"   type="openChannelH248Type"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the H248 protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelH248"  type="closeChannelH248Type"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the H248 protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointH248"  type="createListenpointH248Type"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the H248 protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointH248"  type="removeListenpointH248Type"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the H248 protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageH248"      type="sendMessageH248Type"      minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the H248 protocol using a channel or with the transactionId (user defined).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageH248"   type="receiveMessageH248Type"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the H248 protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_19;-->
                    <!-- liste des methodes pour la pile pcp -->

                    <xs:element name="openChannelPCP"          type="openChannelPCPType"          minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the PCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelPCP"         type="closeChannelPCPType"         minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the PCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointPCP"    type="createListenpointPCPType"    minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the PCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointPCP"    type="removeListenpointPCPType"    minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the PCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessagePCP"          type="sendMessagePCPType"          minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the PCP protocol using a channel or with the transactionId (user defined).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessagePCP"       type="receiveMessagePCPType"       minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the PCP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_20;-->
                    <!-- liste des methodes pour la pile msrp -->

                    <xs:element name="openChannelMSRP"          type="openChannelMSRPType"          minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the MSRP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelMSRP"         type="closeChannelMSRPType"         minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the MSRP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointMSRP"    type="createListenpointMSRPType"    minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the MSRP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointMSRP"    type="removeListenpointMSRPType"    minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the MSRP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageMSRP"          type="sendMessageMSRPType"          minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the MSRP protocol using a channel or with the transactionId (user defined).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageMSRP"       type="receiveMessageMSRPType"       minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the MSRP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_21;-->
                    <!-- liste des methodes pour la pile GTPP -->

                    <xs:element name="openChannelGTP"   type="openChannelGTPType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To open a channel for the GTPP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelGTP"  type="closeChannelGTPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To close a channel for the GTPP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointGTP"  type="createListenpointGTPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the GTPP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointGTP"  type="removeListenpointGTPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the GTPP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageGTP"      type="sendMessageGTPType"      minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the GTPP protocol using a channel or with the transactionId (user defined).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageGTP"   type="receiveMessageGTPType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the GTPP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createProbeGTP" type="createProbeGTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start the probe to capture for the GTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>
                    <xs:element name="removeProbeGTP" type="removeProbeGTPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop the probe to capture for the GTP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>


                    <!--&list_22;-->
                    <!-- liste des methodes pour la pile SNMP -->

                    <xs:element name="createListenpointSNMP"  type="createListenpointSNMPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the SNMP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointSNMP"  type="removeListenpointSNMPType"  minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the SNMP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="sendMessageSNMP"      type="sendMessageSNMPType"      minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the SNMP protocol using a channel or with the transactionId (user defined).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageSNMP"   type="receiveMessageSNMPType"   minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the SNMP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>


                    <!--&list_23;-->
                    <!-- liste des methodes pour la pile MGCP -->

                    <xs:element name="sendMessageMGCP" type="sendMessageMGCPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the MGCP protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageMGCP" type="receiveMessageMGCPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the MGCP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointMGCP" type="createListenpointMGCPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the MGCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointMGCP" type="removeListenpointMGCPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the MGCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createProbeMGCP" type="createProbeMGCPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start the probe to capture for the MGCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeProbeMGCP" type="removeProbeMGCPType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop the probe to capture for the MGCP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>


                    <!--&list_24;-->
                    <!-- liste des methodes pour la pile STUN -->

                    <xs:element name="sendMessageSTUN" type="sendMessageSTUNType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the STUN protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageSTUN" type="receiveMessageSTUNType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the STUN protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createListenpointSTUN" type="createListenpointSTUNType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the STUN protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeListenpointSTUN" type="removeListenpointSTUNType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the STUN protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createProbeSTUN" type="createProbeSTUNType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start the probe to capture for the STUN protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeProbeSTUN" type="removeProbeSTUNType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop the probe to capture for the STUN protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>


                    <!--&list_25;-->
                    <!-- liste des methodes pour la pile H225CS -->

                    <xs:element name="sendMessageH225CS" type="sendMessageH225CSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the H225CS protocol using a channel or a listenpoint (user defined or the default one).</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageH225CS" type="receiveMessageH225CSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the H225CS protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="openChannelH225CS" type="openChannelH225CSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start listening for the H225CS protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="closeChannelH225CS" type="closeChannelH225CSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop listening for the H225CS protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createProbeH225CS" type="createProbeH225CSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start the probe to capture for the H225CS protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeProbeH225CS" type="removeProbeH225CSType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop the probe to capture for the H225CS protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <!--&list_26;-->
                    <xs:element name="sendMessageETHERNET" type="sendMessageETHERNETType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To send a message for the ETHERNET protocol</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="receiveMessageETHERNET" type="receiveMessageETHERNETType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To wait until a message of the IP protocol is received. The operation fails if no message is received until a given timeout value.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="createProbeETHERNET" type="createProbeETHERNETType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To start the probe to capture for the IP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>

                    <xs:element name="removeProbeETHERNET" type="removeProbeETHERNETType" minOccurs="0" maxOccurs="unbounded">
                        <xs:annotation>
                            <xs:appinfo>mixed [0,N]</xs:appinfo>
                            <xs:documentation>To stop the probe to capture for the IP protocol.</xs:documentation>
                        </xs:annotation>
                    </xs:element>


                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--&type_operations_core;-->

    <xs:complexType name="operationType">
        <xs:attribute name="name"    	    type="xs:string"        use="optional">    
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Generic: The operation name</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="description"    type="xs:string"        use="optional">
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Generic: The operation description (just a comment)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="state"    	    type="xs:string"        use="optional">    
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>Generic: A flag to run or not the operation (equivalent to put the operation in comment code)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="operationTypeSimple">
        <xs:simpleContent>
            <xs:extension base="xs:string">    
                <xs:attribute name="name"    	    type="xs:string"        use="optional">    
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Generic: The operation name</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="description"    type="xs:string"        use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Generic: The operation description (just a comment)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="state"    	    type="xs:string"        use="optional">    
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>Generic: A flag to run or not the operation (equivalent to put the operation in comment code)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                       pause -->
    <xs:complexType name="pauseType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="seconds" type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>Pause duration in seconds</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="milliseconds" type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>Pause duration in milliseconds</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


<!--                                                                                        goto -->
    <xs:complexType name="gotoType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="label"   type="xs:string" use="required" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Target label name</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                       label -->
    <xs:complexType name="labelType">
        <xs:complexContent>
            <xs:extension base="operationType">
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                       exit -->
    <xs:complexType name="exitType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="failed"  type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>Failed status: if true, the test will end as a failure (logged at ERROR level), 
                            else false, as a success (logged at WARNING level)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="exception"  type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Description of the exception; this is automacally logged</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                   semaphore -->
    <xs:complexType name="semaphoreType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="action"  type="semaphoreActionType" use="required" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Action to do on this semaphore: notify or wait</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" default="30" >
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>Timeout value in seconds of wait actions</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="permits" type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>Number of permit to give or take</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:simpleType name="semaphoreActionType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="notify" />
            <xs:enumeration value="wait" />
        </xs:restriction>
    </xs:simpleType>

<!--                                                                                    sqlQuery -->
    <xs:complexType name="sqlQueryType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="query"   type="xs:string" use="required" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>SQL query</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                      system -->
    <xs:complexType name="systemType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="command"  type="xs:string" use="required" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>System (shell or dos) command</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                          if -->
    <xs:complexType name="ifType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:all>
                    <xs:element name="condition"  type="conditionType" />
                    <xs:element name="then"       type="doType" minOccurs="0" />
                    <xs:element name="else"       type="doType" minOccurs="0" />
                </xs:all>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="conditionType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="test"  type="testType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"  type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"  type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"  type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


<!--                                                                                          while -->
    <xs:complexType name="whileType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="condition"  type="conditionType" />
                    <xs:element name="do"         type="doType" />
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                          try/finally -->
    <xs:complexType name="tryType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="do"         type="doType" minOccurs="0" />
                    <xs:element name="finally"    type="doType" minOccurs="0" />
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


<!--                                                                                          while -->
    <xs:complexType name="switchType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="case"     type="caseType" minOccurs="0" maxOccurs="unbounded"/>
                    <xs:element name="default"  type="doType"   minOccurs="0" maxOccurs="1"/>
                </xs:sequence>
                <xs:attribute name="parameter"  type="xs:string" use="required" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Value that will be tested to execute the switch</xs:documentation>
                    </xs:annotation>
                </xs:attribute>

            </xs:extension>
        </xs:complexContent>
    </xs:complexType>


    <xs:complexType name="caseType">
        <xs:complexContent>
            <xs:extension base="doType">
                <xs:attribute name="equals"  type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>String the parameter will be compared against (equality)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="matches"  type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>String the parameter will be compared against (regex matching)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>    


<!--                                                                                       for -->
        <xs:complexType name="forType">
            <xs:complexContent>
                <xs:extension base="doType">    
                    <xs:attribute name="index"    type="xs:string"  use="required">    
                        <xs:annotation>
                            <xs:appinfo>String (parameter name)</xs:appinfo>
                            <xs:documentation>The name of the index parameter for the loop. This parameter is available for the user inside the loop.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="from" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The starting value for the loop index.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="to" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The ending value for the loop index.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="step" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The value to increase the index at each loop run (it could be a negative integer). The default value is 1.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>


<!--                                                                                        test -->
    <xs:complexType name="testType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="parameter" type="xs:string"         use="required" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Tested parameter</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="condition" type="xs:string"         use="required" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Name of the test operator (see #####)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="value"     type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Value the parameter will be tested against</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="not"     type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>If true, invert the test condition (default is false).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                   parameter -->
    <xs:complexType name="parameterType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">
                <xs:attribute name="operation" type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Name of the operations that will be applied to the operands. You could use all the characters with an ASCI code less than 128 except the following characters &lt;&gt;&#x22;&#x26;(): which interact with the XML syntax.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="value"     type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Operand 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="value2"    type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Operand 2</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="value3"    type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Operand 3</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="value4"    type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Operand 4</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="value5"    type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Operand 5</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="value6"    type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Operand 6</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="value7"    type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Operand 7</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:simpleContent>            
    </xs:complexType>

<!--                                                                     generic receiveMessage -->
    <xs:complexType name="receiveMessageType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel name to transport the message. Don t use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint name to transport the message. Don t use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="result" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting a message i.e. if we won t receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                       log -->
    <xs:complexType name="logType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">
                <xs:attribute name="level" type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Level of the logs (0/1/2/3 or DEBUG/INFO/WARN/ERROR)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>Destination logger for this log : Main or Scenario</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                      user statistics -->
    <xs:complexType name="statsType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="counter"   type="statsCounterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="flow"      type="statsFlowType" minOccurs="0" maxOccurs="unbounded" />
                    <!-- DEPRECATED -->
                    <xs:element name="histogram" type="statsHistogramType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="value" type="statsHistogramType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="percent"   type="statsPercentType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="text"   type="statsTextType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="reset"     type="statsResetType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="statsCounterType">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="increase"  type="statsAddType" minOccurs="0" maxOccurs="unbounded" />
            <xs:element name="decrease"  type="statsAddType" minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
        <xs:attribute name="name"        type="xs:string" use="required" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Name of the stats counter</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="summary"   type="xs:string" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Summary description of stat counter (used in display only)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="complete" type="xs:string" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Complete description of the counter (used in display only)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shortDesc"   type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="description"    type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="longDesc"    type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="statsFlowType">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="increase"  type="statsAddType" minOccurs="0" maxOccurs="unbounded" />
            <xs:element name="decrease"  type="statsAddType" minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
        <xs:attribute name="name"        type="xs:string" use="required" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Name of the stats counter</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="summary"   type="xs:string" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Summary description of stat counter (used in display only)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="complete" type="xs:string" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Complete description of the counter (used in display only)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shortDesc"   type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="description"    type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="longDesc"    type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="statsHistogramType">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="newValue"  type="statsAddType" minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
        <xs:attribute name="name"        type="xs:string" use="required" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Name of the stats counter</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="summary"   type="xs:string" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Summary description of stat counter (used in display only)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="complete" type="xs:string" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Complete description of the counter (used in display only)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shortDesc"   type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="description"    type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="longDesc"    type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="statsPercentType">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="incValue"  type="statsAddType" minOccurs="0" maxOccurs="unbounded" />
            <xs:element name="incTotal"  type="statsAddType" minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
        <xs:attribute name="name"        type="xs:string" use="required" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Name of the stats counter</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="summary"   type="xs:string" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Summary description of stat counter (used in display only)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="complete" type="xs:string" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Complete description of the counter (used in display only)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shortDesc"   type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="description"    type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="longDesc"    type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="statsTextType">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="newValue"  type="statsAddType" minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
        <xs:attribute name="name"        type="xs:string" use="required" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Name of the stats counter</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="summary"   type="xs:string" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Summary description of stat counter (used in display only)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="complete" type="xs:string" >
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>Complete description of the counter (used in display only)</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="shortDesc"   type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="description"    type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="longDesc"    type="xs:string" >
            <xs:annotation>
                <xs:appinfo></xs:appinfo>
                <xs:documentation>DEPRECATED</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <xs:complexType name="statsAddType">
        <xs:simpleContent>
            <xs:extension base="xs:string">    
                <xs:attribute name="value" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>Value that will be added to the counter</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="seconds" type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>Timestamp in seconds at which the counter is added</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="milliseconds" type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>Timestamp in milliseconds at which the counter is added</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>    
        </xs:simpleContent>
    </xs:complexType>

    <xs:complexType name="statsResetType">
        <xs:simpleContent>
            <xs:extension base="xs:string">    
                <xs:attribute name="path" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The path in the stats tree to reach the counter to reset</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="name" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the counter to reset</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>    
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                          function -->
<xs:complexType name="functionType">
    <xs:sequence>
        <xs:element name="input"       type="inputFunctionType" minOccurs="0" maxOccurs="1" />
        <xs:element name="do"          type="doType" minOccurs="0" maxOccurs="1" />
        <xs:element name="output"      type="outputFunctionType" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
    <xs:attribute name="file"     type="xs:string" >
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>file to import functions from</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="name"     type="xs:string" >
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>name of the function</xs:documentation>
        </xs:annotation>
    </xs:attribute>
</xs:complexType>

<xs:complexType name="inputFunctionType">
    <xs:sequence>
        <xs:element name="parameter"        type="parameterInputFunctionType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
</xs:complexType>

<xs:complexType name="outputFunctionType">
    <xs:sequence>
        <xs:element name="parameter"        type="parameterOutputFunctionType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
</xs:complexType>

<!--                                                                                          function -->
<xs:complexType name="callType">
    <xs:sequence>
        <xs:element name="input"        type="inoutputCallType" minOccurs="0" maxOccurs="1" />
        <xs:element name="output"       type="inoutputCallType" minOccurs="0" maxOccurs="1" />
    </xs:sequence>
    <xs:attribute name="name"     type="xs:string" >
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>name of the function to call</xs:documentation>
        </xs:annotation>
    </xs:attribute>
</xs:complexType>

<xs:complexType name="inoutputCallType">
    <xs:sequence>
        <xs:element name="parameter"        type="parameterInputOutputCallType" minOccurs="0" maxOccurs="unbounded" />
    </xs:sequence>
</xs:complexType>

<!--                                                                                          arg -->
<xs:complexType name="parameterInputFunctionType">
    <xs:attribute name="name"     type="xs:string" >
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>name of the input argument</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="default"     type="xs:string" >
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>default value of the input argument, if not passed to the function. If not defined, the argument will be mandatory in call</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="type"    type="xs:string" >
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>type of the input argument, used to do some checks</xs:documentation>
        </xs:annotation>
    </xs:attribute>
</xs:complexType>

<!--                                                                                          arg -->
<xs:complexType name="parameterOutputFunctionType">
    <xs:attribute name="name"     type="xs:string" >
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>value of the output argument</xs:documentation>
        </xs:annotation>
    </xs:attribute>
</xs:complexType>




<xs:complexType name="parameterInputOutputCallType">
    <xs:attribute name="name"     type="xs:string" >
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>name of the argument</xs:documentation>
        </xs:annotation>
    </xs:attribute>
    <xs:attribute name="value"     type="xs:string" >
        <xs:annotation>
            <xs:appinfo>String</xs:appinfo>
            <xs:documentation>value of the argument that will be passed to the function</xs:documentation>
        </xs:annotation>
    </xs:attribute>
</xs:complexType>


<!--&type_operations_1;-->
<!--                                                                       START OF DIAMETER PROTOCOL -->

  <!--                                                                          openChannel -->
  <xs:complexType name="openChannelDIAMETERType">
      <xs:complexContent>
          <xs:extension base="operationType">
              <xs:attribute name="localHost" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>String</xs:appinfo>
                      <xs:documentation>The channel local host (sometimes called the source host) of the channel. It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="localPort" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>Integer</xs:appinfo>
                      <xs:documentation>The channel local port (sometimes called the source port) of the channel. The default value is chosen by the tool.</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="localURL" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>String (url)</xs:appinfo>
                      <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                  </xs:annotation>
              </xs:attribute>             
              <xs:attribute name="remoteHost" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>String</xs:appinfo>
                      <xs:documentation>The channel remote host (sometimes called the destination host) of the channel. It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="remotePort" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>Integer</xs:appinfo>
                      <xs:documentation>The channel remote port (sometimes called the destination port) of the channel.</xs:documentation>
                  </xs:annotation>
              </xs:attribute> 
              <xs:attribute name="remoteURL" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>String (url)</xs:appinfo>
                      <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                  </xs:annotation>
              </xs:attribute> 
              <xs:attribute name="transport" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                      <xs:documentation>The channel transport.</xs:documentation>
                  </xs:annotation>
              </xs:attribute>            
          </xs:extension>
      </xs:complexContent>
  </xs:complexType>

  <!--                                                                         closeChannel -->
  <xs:complexType name="closeChannelDIAMETERType">
      <xs:complexContent>
          <xs:extension base="operationType"/>
      </xs:complexContent>
  </xs:complexType>


  <!--                                                                          createListenpoint -->
  <xs:complexType name="createListenpointDIAMETERType">
      <xs:complexContent>
          <xs:extension base="operationType">
              <xs:sequence>
                  <xs:element name="nodeSettings"     type="nodeSettingsType"       minOccurs="0" maxOccurs="1" />
                  <xs:element name="avp"     type="avpDIAMType"       minOccurs="0" maxOccurs="unbounded" />
              </xs:sequence>
              <xs:attribute name="localHost" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>String</xs:appinfo>
                      <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="localPort" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>Integer</xs:appinfo>
                      <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="localURL" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>String (url)</xs:appinfo>
                      <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                  </xs:annotation>
              </xs:attribute>             
              <xs:attribute name="listenUDP" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>Boolean</xs:appinfo>
                      <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="listenTCP" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>Boolean</xs:appinfo>
                      <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>Boolean</xs:appinfo>
                      <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="listenTLS" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>Boolean</xs:appinfo>
                      <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>Integer</xs:appinfo>
                      <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="transport" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS, RFC)</xs:appinfo>
                      <xs:documentation>The default transport used to transport messages (in case the transport is not specified int the message content). The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
          </xs:extension>
      </xs:complexContent>
  </xs:complexType>
  <!--                                                                         removeListenpoint -->
  <xs:complexType name="removeListenpointDIAMETERType">
      <xs:complexContent>
          <xs:extension base="operationType"/>
      </xs:complexContent>
  </xs:complexType>

  <!--                                                                          createProbe -->
  <xs:complexType name="createProbeDIAMETERType">
      <xs:complexContent>
          <xs:extension base="operationType">
              <xs:attribute name="networkInterface" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>String</xs:appinfo>
                      <xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="captureFilter" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>String</xs:appinfo>
                      <xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="filename" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>String</xs:appinfo>
                      <xs:documentation>The filename to capture the network packets.</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="regexFilter" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>String</xs:appinfo>
                      <xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
              <xs:attribute name="promiscuousMode" type="xs:string" use="optional">
                  <xs:annotation>
                      <xs:appinfo>Boolean</xs:appinfo>
                      <xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
                  </xs:annotation>
              </xs:attribute>
          </xs:extension>
      </xs:complexContent>
  </xs:complexType>
  <!--                                                                         removeProbe -->
  <xs:complexType name="removeProbeDIAMETERType">
      <xs:complexContent>
          <xs:extension base="operationType"/>
      </xs:complexContent>
  </xs:complexType>

<!--                                                                            sendMessage -->
    <xs:complexType name="sendMessageDIAMETERType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="header"  type="headerDIAMType" />
                    <xs:element name="avp"     type="avpDIAMType"       minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the channel to transport the message. Don t use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the listenpoint to transport the message. Don t use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The remote host to send the message to. Don t use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The remote port to send the message to. Don t use it with the channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL to send the message to. Don t use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The protocol transport to send the message to. Don t use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="destScenario" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (scenario name)</xs:appinfo>
                        <xs:documentation>The destination scenario if the request comes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="delay" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" >
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>DEPRECATED : The flag to indicate whether the message is a request ("True") or a response ("false").</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                            receiveMessage -->
    <xs:complexType name="receiveMessageDIAMETERType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the channel to transport the message. Don t use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint name to transport the message. Don t use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="probe" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The probe name to capture the message on.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="result" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting a message i.e. if we won t receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                         nodeSettings -->
    <xs:complexType name="nodeSettingsType">
        <xs:attribute name="idleTimeout" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Integer</xs:appinfo>
                <xs:documentation>The idle close timeout value after which the connection will closed with reason=busy unless there has been non-watchdog traffic on the connection. If 0 then idle timeout is disabled and connections will be kept open.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="watchdogInterval" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Integer</xs:appinfo>
                <xs:documentation>The desired interval (in milliseconds) between the stack automaticallys sends DWR/DWA message .</xs:documentation>
            </xs:annotation>
        </xs:attribute>		
    </xs:complexType>

<!--                                                                                   header -->
    <xs:complexType name="headerDIAMType">
        <xs:attribute name="request" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>The flag to indicate whether the message is a request ("True") or a response ("false").</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="command" type="xs:string" use="required">
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>The command code of the message : format &lt;label&gt;:&lt;code&gt;.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="applicationId" type="xs:string" use="required">
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>The application id of the message : format &lt;label&gt;:&lt;code&gt;.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="hopByHop" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Integer</xs:appinfo>
                <xs:documentation>The hop by hop identifier (transaction ID).</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="endToEnd" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Integer</xs:appinfo>
                <xs:documentation>The end to end identifier (transaction ID).</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="proxiable" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>The proxiable flag.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="p" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>The proxiable flag.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="error" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>The error flag.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="e" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>The error flag.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="retransmit" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>The retransmit flag.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="r" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>The retransmit flag.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

<!--                                                                                         avp -->
    <xs:complexType name="avpDIAMType">
        <xs:sequence>
            <xs:element name="avp"  type="avpDIAMType"  minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
        <xs:attribute name="code" type="xs:string" use="required">
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>The label and/or code of the AVP : format &lt;label&gt;:&lt;code&gt;.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="value" type="xs:string">
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>The value of the AVP : depending of the AVP type.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="type" type="xs:string">
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>The type of the AVP : according to the dictionary; "binary" or "grouped" are also possible. If omitted then we take it from the dictionary.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="vendorId" type="xs:string">
            <xs:annotation>
                <xs:appinfo>String</xs:appinfo>
                <xs:documentation>The vendor id of the AVP : format &lt;label&gt;:&lt;code&gt;</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="mandatory" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>The mandatory flag of the AVP.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="m" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>The mandatory flag of the AVP.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="private" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>The private flag of the AVP.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="p" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>The private flag of the AVP.</xs:documentation>
            </xs:annotation>
        </xs:attribute>        
        <xs:attribute name="state" type="xs:string">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>The state flag of the AVP : if "false" then the AVP is not sent.</xs:documentation>
            </xs:annotation>
        </xs:attribute>        
    </xs:complexType>

    <!--&type_operations_2;-->
<!--                                                                       START OF SIP PROTOCOL -->

        <!--                                                                          createListenpoint -->
        <xs:complexType name="createListenpointSIPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>             
                    <xs:attribute name="listenUDP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenTCP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenTLS" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="transport" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS, RFC)</xs:appinfo>
                            <xs:documentation>The default transport used to transport messages (in case the transport is not specified int the message content). The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
        <!--                                                                         removeListenpoint -->
        <xs:complexType name="removeListenpointSIPType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                          createProbe -->
        <xs:complexType name="createProbeSIPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="networkInterface" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="captureFilter" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="filename" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The filename to capture the network packets.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="regexFilter" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="promiscuousMode" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
        <!--                                                                         removeProbe -->
        <xs:complexType name="removeProbeSIPType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                          sendMessage -->
        <xs:complexType name="sendMessageSIPType">
            <xs:simpleContent>
                <xs:extension base="operationTypeSimple">
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The name of the listenpoint to transport the message. Don t use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The remote host to send the message to. Don t use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remotePort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The remote port to send the message to. Don t use it with the channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The remote URL to send the message to. Don t use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="transport" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS, RFC)</xs:appinfo>
                            <xs:documentation>The protocol transport to send the message to. Don t use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="destScenario" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (scenario name)</xs:appinfo>
                            <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="delay" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
        <!--                                                                         receiveMessage -->
        <xs:complexType name="receiveMessageSIPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel name to transport the message. Don t use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint name to transport the message. Don t use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="probe" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The probe name to capture the message on.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="request" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="type" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="result" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="timeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting a message i.e. if we won t receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--&type_operations_3;-->
<!--                                                                         BEGIN OF RTP PROTOCOL -->


    <!--                                                                          createListenpoint -->
    <xs:complexType name="createListenpointRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="srtpSender" 	type="srtpType"	minOccurs="0" maxOccurs="1" />
                    <xs:element name="srtpReceiver" type="srtpType"	minOccurs="0" maxOccurs="1" />
                </xs:sequence>
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="listenUDP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTCP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--                                                                         removeListenpoint -->
    <xs:complexType name="removeListenpointRTPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

    <!--                                                                          createProbe -->
    <xs:complexType name="createProbeRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="networkInterface" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="captureFilter" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="filename" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The filename to capture the network packets.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="regexFilter" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="promiscuousMode" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--                                                                         removeProbe -->
    <xs:complexType name="removeProbeRTPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

    <!--                                                                          sendMessage -->
    <xs:complexType name="sendMessageRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="packet" type="packetType" minOccurs="0" maxOccurs="1"/>
                    <xs:element name="header" type="headerType" minOccurs="0" maxOccurs="1"/>
                    <xs:element name="payload" type="payloadType" minOccurs="0" maxOccurs="unbounded"/>                   			
                </xs:sequence>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the listenpoint to transport the message. Don t use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The remote host to send the message to. Don t use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The remote port to send the message to. Don t use it with the channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL to send the message to. Don t use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The protocol transport to send the message to. Don t use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="destScenario" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (scenario name)</xs:appinfo>
                        <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="delay" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--                                                                         receiveMessage -->
    <xs:complexType name="receiveMessageRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint name to transport the message. Don t use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="probe" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The probe name to capture the message on.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="result" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (RTPFLOW.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting a message i.e. if we won t receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--                                                                          createListenpoint -->
    <xs:complexType name="createListenpointRTPFLOWType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="srtpSender" 	type="srtpType"	minOccurs="0" maxOccurs="1" />
                    <xs:element name="srtpReceiver" type="srtpType"	minOccurs="0" maxOccurs="1" />
                    <xs:element name="flow" type="listenpointFlowType" minOccurs="0" maxOccurs="1"/>
                </xs:sequence>
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="listenUDP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTCP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="listenpointFlowType">
        <xs:attribute name="endTimerNoPacket"	    type="xs:string" use="optional">
            <xs:annotation>
                <xs:appinfo>Float</xs:appinfo>
                <xs:documentation>A RTPflow message is return by the tool when no packet is received during this timer value (in seconds).</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="endTimerSilentFlow"	    type="xs:string" use="optional">
            <xs:annotation>
                <xs:appinfo>Float</xs:appinfo>
                <xs:documentation>A RTPflow is return by the tool when silent packets are received during this timer value (in seconds).</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="endTimerPeriodic"	    type="xs:string" use="optional">
            <xs:annotation>
                <xs:appinfo>Float</xs:appinfo>
                <xs:documentation>A RTPflow message is return by the tool after this period timer (in seconds).</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="qosMeasurment"	    type="xs:string" use="optional">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>Do or don t do qos computing on messages received by this listenpoint. Must be false if ignoreReceivedMessages is true</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="ignoreReceivedMessages"	    type="xs:string" use="optional">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>Ignore content fo the received messages (memory performances).
                    The following path for setFromMessage will not work anymore : header.payloadType, header.seqnum, 
                    header.timestamp, header.mark, payload.xxx, flow.payload.xxx
                </xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

    <!--                                                                         removeListenpoint -->
    <xs:complexType name="removeListenpointRTPFLOWType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>


    <!--                                                                          createProbe -->
    <xs:complexType name="createProbeRTPFLOWType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="networkInterface" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="captureFilter" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="filename" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The filename to capture the network packets.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="regexFilter" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="promiscuousMode" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--                                                                         removeProbe -->
    <xs:complexType name="removeProbeRTPFLOWType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          sendMessage -->
        <xs:complexType name="sendMessageRTPFLOWType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence>
                        <xs:sequence>
                            <xs:element name="flow" type="flowType" minOccurs="0" maxOccurs="1"/>
                        </xs:sequence>
                    </xs:sequence>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The name of the listenpoint to transport the message. Don t use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The remote host to send the message to. Don t use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remotePort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The remote port to send the message to. Don t use it with the channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The remote URL to send the message to. Don t use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="transport" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                            <xs:documentation>The protocol transport to send the message to. Don t use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="destScenario" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (scenario name)</xs:appinfo>
                            <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="delay" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
        <!--                                                                         receiveMessage -->
        <xs:complexType name="receiveMessageRTPFLOWType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel name to transport the message. Don t use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint name to transport the message. Don t use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="probe" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The probe name to capture the message on.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="request" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="type" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="result" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="timeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (RTPFLOW.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting a message i.e. if we won t receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>


<!--                                                                                   flow -->
    <xs:complexType name="flowType">
        <xs:sequence>
            <xs:element name="header" type="headerType" minOccurs="1" maxOccurs="1"/>
            <xs:element name="payload" type="payloadType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="duration"	    type="xs:string" use="optional">
            <xs:annotation>
                <xs:appinfo>Float</xs:appinfo>
                <xs:documentation>The duration of the RTP flow in seconds. One of the duration or packetNumber attribute is required to determine the flow end. If both are set, the flow will stop at the minus of the both.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="packetNumber"	type="xs:string" use="optional">
            <xs:annotation>
                <xs:appinfo>Integer</xs:appinfo>
                <xs:documentation>The packet number of the RTP flow. One of the duration or packetNumber attribute is required to determine the flow end. If both are set, the flow will stop at the minus of the both.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="synchronous" type="xs:string" use="optional">
            <xs:annotation>
                <xs:appinfo>Boolean</xs:appinfo>
                <xs:documentation>Whether the flow sending is synchronous or not. The default value is true.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="bitRate"	    type="xs:string" use="optional">
            <xs:annotation>
                <xs:appinfo>Float</xs:appinfo>
                <xs:documentation>The bit rate of the RTP flow. One of the biteRate or deltaTime attribute is required to determine the speed flow.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="deltaTime" type="xs:string" use="optional">
            <xs:annotation>
                <xs:appinfo>Float</xs:appinfo>
                <xs:documentation>The time between the sending of 2 RTP packets. One of the biteRate or deltaTime attribute is required to determine the speed flow.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="deltaTimestamp" type="xs:string" use="optional">
            <xs:annotation>
                <xs:appinfo>Float</xs:appinfo>
                <xs:documentation>The delta number of samples given by the RTP timestamp between 2 messages.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="jitterDelay"  	type="xs:string" use="optional">
            <xs:annotation>
                <xs:appinfo>Float</xs:appinfo>
                <xs:documentation>The gigue delay of the RTP flow ie a random time delay added on each RTP packet timestamp. The default value is 0.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
        <xs:attribute name="packetLost"  	type="xs:string" use="optional">
            <xs:annotation>
                <xs:appinfo>Float</xs:appinfo>
                <xs:documentation>The percentage of lost packet. The default value is 0.</xs:documentation>
            </xs:annotation>
        </xs:attribute>
    </xs:complexType>

<!--                                                                                   packet -->
    <xs:complexType name="packetType">
        <xs:sequence>
            <xs:element name="header" type="headerType" minOccurs="1" maxOccurs="1"/>
            <xs:element name="payload" type="payloadType" minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
    </xs:complexType>

<!--                                                                                   header -->
    <xs:complexType name="headerType">
        <xs:attribute name="channel"	    type="xs:string" />
        <xs:attribute name="ssrc"	    type="xs:string" use="required" />
        <xs:attribute name="payloadType"    type="xs:string" use="required"/>
        <xs:attribute name="seqnum"  	    type="xs:string" />
        <xs:attribute name="timestamp"      type="xs:string" />
        <xs:attribute name="mark"           type="xs:string" />
    </xs:complexType>

<!--                                                                                   payload -->
    <xs:complexType name="payloadType">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="format"	    type="xs:string" />
                <xs:attribute name="length"	    type="xs:string" />        	
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>
<!--																					srtp -->
        <xs:complexType name="srtpType">
            <xs:attribute name="algorithm"			type="xs:string" use="required" />
            <xs:attribute name="masterKeyAndSalt"	type="xs:string" use="required" />
            <xs:attribute name="keyDerivationRate"	type="xs:string" />
            <xs:attribute name="mki"				type="xs:string" />
        </xs:complexType>

<!--************************************************************************************************-->
<!--**************************************** OBSOLETE **********************************************-->
<!--************************************************************************************************-->

<!--                                                                           openConnectionRTP -->
    <xs:complexType name="openConnectionRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="sessionName"    type="xs:string" use="required"/>
                <xs:attribute name="localHost"      type="xs:string" />
                <xs:attribute name="localPort"      type="xs:string" />
                <xs:attribute name="remoteHost"     type="xs:string" use="required"/>
                <xs:attribute name="remotePort"     type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                           closeConnectionRTP -->
    <xs:complexType name="closeConnectionRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="sessionName"    type="xs:string" use="required"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                           sendPacketRTP -->
    <xs:complexType name="sendPacketRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence>
                    <xs:element name="packet" type="packetType" minOccurs="0" maxOccurs="1"/>
                    <!--xs:element name="packet" type="packetType" minOccurs="0" maxOccurs="unbounded"/-->
                </xs:sequence>
                <xs:attribute name="sessionName"    type="xs:string" />
                <xs:attribute name="destScenario"   type="xs:string" />
                <!--xs:attribute name="payloadType" type="xs:string" /-->
                <!--xs:attribute name="ssrc" 	    type="xs:string" /-->
                <!--xs:attribute name="bandwith"    type="xs:string" /-->
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                           receivePacketRTP -->
    <xs:complexType name="receivePacketRTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
                <xs:attribute name="sessionName"     type="xs:string" />
                <xs:attribute name="payloadType"     type="xs:string" />
                <xs:attribute name="timeout"         type="xs:string" />
                <xs:attribute name="failedOnTimeout" type="xs:string" />
                <xs:attribute name="failedOnReceive" type="xs:string" />
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         END OF RTP PROTOCOL -->

    <!--&type_operations_4;-->
<!--                                                                       START OF HTTP PROTOCOL -->

<!--                                                                          openChannel -->
<xs:complexType name="openChannelHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:attribute name="localHost" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="localPort" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Integer</xs:appinfo>
                    <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="localURL" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String (url)</xs:appinfo>
                    <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                </xs:annotation>
            </xs:attribute>             
            <xs:attribute name="remoteHost" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The channel remote host (sometimes called the destination host) of the channel. It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remotePort" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Integer</xs:appinfo>
                    <xs:documentation>The channel remote port (sometimes called the destination port) of the channel.</xs:documentation>
                </xs:annotation>
            </xs:attribute> 
            <xs:attribute name="remoteURL" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String (url)</xs:appinfo>
                    <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                </xs:annotation>
            </xs:attribute> 
            <xs:attribute name="transport" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                    <xs:documentation>The channel transport.</xs:documentation>
                </xs:annotation>
            </xs:attribute>  
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--                                                                         closeChannel -->
<xs:complexType name="closeChannelHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType"/>
    </xs:complexContent>
</xs:complexType>

<!--                                                                               sendMessage -->
<xs:complexType name="sendMessageHTTPType">
    <xs:simpleContent>
        <xs:extension base="operationTypeSimple">
            <xs:attribute name="channel" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The name of the channel to transport the message. Don t use it with listenpoint (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remoteHost" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The remote host to send the message to. Don t use it with the channel (incompatible).</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remotePort" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Integer</xs:appinfo>
                    <xs:documentation>The remote port to send the message to. Don t use it with the channel (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="remoteURL" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String (url)</xs:appinfo>
                    <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="transport" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                    <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="destScenario" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String (scenario name)</xs:appinfo>
                    <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="delay" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Float</xs:appinfo>
                    <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="transactionId"  type="xs:string">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:simpleContent>
</xs:complexType>

<!--                                                                            receiveMessage -->
<xs:complexType name="receiveMessageHTTPType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
            </xs:sequence>
            <xs:attribute name="channel" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="request" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="result" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="timeout" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Float</xs:appinfo>
                    <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--&type_operations_6;-->
<!--                                                                      BEGIN OF TCP PROTOCOL -->


<!--                                                                          openChannel -->
        <xs:complexType name="openChannelTCPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>             
                    <xs:attribute name="remoteHost" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remotePort" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute> 
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                         closeChannel -->
        <xs:complexType name="closeChannelTCPType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                          createListenpoint -->
        <xs:complexType name="createListenpointTCPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>             
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
        <!--                                                                         removeListenpoint -->
        <xs:complexType name="removeListenpointTCPType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                          sendMessageTCP -->
        <xs:complexType name="sendMessageTCPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence>
                        <xs:element name="data" type="dataTypeTCP" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="destScenario" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (scenario name)</xs:appinfo>
                            <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="delay" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                         receiveMessage -->
        <xs:complexType name="receiveMessageTCPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>				
                    <xs:attribute name="request" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="type" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="result" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>				
                    <xs:attribute name="timeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

<!--                                                                                       data -->
    <xs:complexType name="dataTypeTCP">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="format"       type="dataTypeTypeTCP" />
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                   dataTypeTCP -->
    <xs:simpleType name="dataTypeTypeTCP">
        <xs:restriction base="xs:string">
            <xs:enumeration value="text" />
            <xs:enumeration value="binary" />
        </xs:restriction>
    </xs:simpleType>    

    <!--&type_operations_7;-->
<!--                                                                      BEGIN OF UDP PROTOCOL -->

    <!--                                                                          openChannel -->
    <xs:complexType name="openChannelUDPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="remoteHost" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute> 
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelUDPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpoint -->
        <xs:complexType name="createListenpointUDPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>             
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                         removeListenpoint -->
        <xs:complexType name="removeListenpointUDPType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                          sendMessage -->
        <xs:complexType name="sendMessageUDPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence>
                        <xs:element name="data" type="dataUdpType" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remotePort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="destScenario" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (scenario name)</xs:appinfo>
                            <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="delay" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="length"      	type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The length of the message.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                         receiveMessage -->
        <xs:complexType name="receiveMessageUDPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="request" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="type" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="result" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>				
                    <xs:attribute name="timeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

<!--                                                                                       data -->
    <xs:complexType name="dataUdpType">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="format"       type="dataUdpFormatType" />
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                   dataUdpFormatType -->
    <xs:simpleType name="dataUdpFormatType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="text" />
            <xs:enumeration value="binary" />
        </xs:restriction>
    </xs:simpleType>


    <!--&type_operations_8;-->
<!--                                                                      BEGIN OF SCTP PROTOCOL -->

<!--                                                                          openChannel -->
        <xs:complexType name="openChannelSCTPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence>
                        <xs:element name="sctp" type="channelSctpType" minOccurs="0" maxOccurs="1"/>
                    </xs:sequence>
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>             
                    <xs:attribute name="remoteHost" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remotePort" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute> 
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                         closeChannel -->
        <xs:complexType name="closeChannelSCTPType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                                       sctp message -->
        <xs:complexType name="channelSctpType">
            <xs:simpleContent>
                <xs:extension base="xs:string">
                    <xs:attribute name="num_ostreams"      	type="xs:string" >
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>This is an integer number representing the number 
                                of streams that the application wishes to be able to send to.  
                                This number is confirmed in the SCTP_COMM_UP notification and must 
                                be verified since it is a negotiated number with the remote endpoint.  
                                The default value of 0 indicates to use the endpoint default value.
                            </xs:documentation>
                        </xs:annotation>                                                         
                    </xs:attribute>
                    <xs:attribute name="max_instreams"      type="xs:string" >
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>This value represents the maximum number of inbound 
                                streams the application is prepared to support. This value is bounded 
                                by the actual implementation.  In other words the user MAY be able to 
                                support more streams than the Operating System.  In such a case, the 
                                Operating System limit overrides the value requested by the user. 
                                The default value of 0 indicates to use the endpoints default value.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="max_attempts"     	type="xs:string" >
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>This integer specifies how many attempts the SCTP 
                                endpoint should make at resending the INIT.  This value overrides 
                                the system SCTP 'Max.Init.Retransmits' value.  
                                The default value of 0 indicates to use the endpoints default value.  
                                This is normally set to the system's default 'Max.Init.Retransmit' 
                                value.
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="max_initTimeo"      	type="xs:string" >
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>This value represents the largest Time-Out or 
                                RTO value (in milliseconds) to use in attempting an INIT.  
                                Normally the 'RTO.Max' is used to limit the doubling of the RTO 
                                upon timeout.  For the INIT message this value MAY override 
                                'RTO.Max'.  This value MUST NOT influence 'RTO.Max' during 
                                data transmission and is only used to bound the initial setup time.  
                                A default value of 0 indicates to use the endpoints default value.  
                                This is normally set to the system's 'RTO.Max' value (60 seconds).
                            </xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>

<!--                                                                          createListenpoint -->
        <xs:complexType name="createListenpointSCTPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>             
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                         removeListenpoint -->
        <xs:complexType name="removeListenpointSCTPType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                          sendMessage -->
        <xs:complexType name="sendMessageSCTPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence>
                        <xs:element name="sctp" type="messageSctpType" minOccurs="0" maxOccurs="1"/>
                        <xs:element name="data" type="dataSctpType" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="destScenario" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (scenario name)</xs:appinfo>
                            <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="delay" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                         receiveMessage -->
        <xs:complexType name="receiveMessageSCTPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="request" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="type" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="result" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>								
                    <xs:attribute name="timeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                                       sctp message -->
        <xs:complexType name="messageSctpType">
            <xs:simpleContent>
                <xs:extension base="xs:string">
                    <xs:attribute name="stream" type="xs:string">
                        <xs:annotation>
                            <xs:appinfo>Integer 16 bits unsigned</xs:appinfo>
                            <xs:documentation>Stream identifier: Identifies the stream to which the following user data belongs.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>                
                    <xs:attribute name="ssn" type="xs:string">
                        <xs:annotation>
                            <xs:appinfo>Integer 16 bits unsigned</xs:appinfo>
                            <xs:documentation>Stream Sequence Number: Represents the stream sequence number of the following user data within the stream S.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>                                    
                    <xs:attribute name="ppid" type="xs:string">
                        <xs:annotation>
                            <xs:appinfo>Integer 32 bits unsigned</xs:appinfo>
                            <xs:documentation>Payload Protocol Identifier: Represents an application (or upper layer) specified protocol identifier.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>                
                    <xs:attribute name="flags" type="xs:string">
                        <xs:annotation>
                            <xs:appinfo>Boolean 0|1</xs:appinfo>
                            <xs:documentation>U bit: The (U)nordered bit, if set to '1', indicates that this is an unordered DATA chunk, and there is no Stream Sequence Number assigned to this DATA chunk.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>                
                    <xs:attribute name="context" type="xs:string">
                        <xs:annotation>
                            <xs:appinfo>Integer 32 bits unsigned</xs:appinfo>
                            <xs:documentation>Context: Not part of the protocol but its internal data in the SCTP stack. So you are not able to set it.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>                
                    <xs:attribute name="ttl" type="xs:string">
                        <xs:annotation>
                            <xs:appinfo>Integer 32 bits unsigned</xs:appinfo>
                            <xs:documentation>TTL=Time To Live: Not part of the protocol but its internal data in the SCTP stack. So you are not able to set it.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>                                
                    <xs:attribute name="tsn" type="xs:string">
                        <xs:annotation>
                            <xs:appinfo>Integer 32 bits unsigned</xs:appinfo>
                            <xs:documentation>TSN = Transmission Sequence Number: Represents the TSN for this DATA chunk. So you are not able to set it.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>                
                    <xs:attribute name="cumtsn" type="xs:string">
                        <xs:annotation>
                            <xs:appinfo>Integer 32 bits unsigned</xs:appinfo>
                            <xs:documentation>Cumulative TSN: Represents the cumulative TSN for this DATA chunk. So you are not able to set it.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>                
                    <xs:attribute name="aid" type="xs:string">
                        <xs:annotation>
                            <xs:appinfo>Integer 32 bits unsigned</xs:appinfo>
                            <xs:documentation>Association Identifier: Not part of the protocol but its internal data in the SCTP stack. So you are not able to set it.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>                
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>

<!--                                                                                       data -->
    <xs:complexType name="dataSctpType">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="format"       type="dataSctpFormatType" />
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                   dataSctpFormatType -->
    <xs:simpleType name="dataSctpFormatType">
        <xs:restriction base="xs:string">
            <xs:enumeration value="text" />
            <xs:enumeration value="binary" />
        </xs:restriction>
    </xs:simpleType>


    <!--&type_operations_9;-->
<!--                                                                       START OF Radius PROTOCOL -->

<!--                                                                          createListenpoint -->
        <xs:complexType name="createListenpointRADIUSType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>             
                    <xs:attribute name="listenUDP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenTCP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenTLS" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="transport" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                            <xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="secret" type="xs:string" use="required" >
                        <xs:annotation>
                            <xs:appinfo>string</xs:appinfo>
                            <xs:documentation>The share secret to compute the Authenticator data.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                         removeListenpoint -->
        <xs:complexType name="removeListenpointRADIUSType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                          sendMessage -->
        <xs:complexType name="sendMessageRADIUSType">
            <xs:complexContent>
                <!--<xs:extension base="operationTypeSimple">-->
                    <xs:extension base="operationType">
                        <xs:sequence>
                            <xs:element name="header"     type="headerRadiusType" />
                            <xs:element name="avp"        type="avpRadiusType"       minOccurs="0" maxOccurs="unbounded" />
                        </xs:sequence>
                        <xs:attribute name="listenpoint" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>String</xs:appinfo>
                                <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="remoteHost" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>String</xs:appinfo>
                                <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="remotePort" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>Integer</xs:appinfo>
                                <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="remoteURL" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>String (url)</xs:appinfo>
                                <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="transport" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                                <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="destScenario" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>String (scenario name)</xs:appinfo>
                                <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="delay" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>Float</xs:appinfo>
                                <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="request"      type="xs:string" >
                            <xs:annotation>
                                <xs:appinfo>Boolean</xs:appinfo>
                                <xs:documentation>The flag to indicate whether the message is a request ("True") or a response ("false").</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                    </xs:extension>
                </xs:complexContent>
            </xs:complexType>

            <!--                                                                         receiveMessage -->
            <xs:complexType name="receiveMessageRADIUSType">
                <xs:complexContent>
                    <xs:extension base="operationType">
                        <xs:sequence minOccurs="0" maxOccurs="unbounded">
                            <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                            <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                            <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                            <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                            <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        </xs:sequence>
                        <xs:attribute name="listenpoint" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>String</xs:appinfo>
                                <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="request" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>Boolean</xs:appinfo>
                                <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="type" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>String</xs:appinfo>
                                <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="result" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>String</xs:appinfo>
                                <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="timeout" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>Float</xs:appinfo>
                                <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (RADIUS.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>Boolean</xs:appinfo>
                                <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>Boolean</xs:appinfo>
                                <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                    </xs:extension>
                </xs:complexContent>
            </xs:complexType>

<!--                                                                                   header -->
    <xs:complexType name="headerRadiusType">
        <xs:attribute name="identifier"     type="xs:string" />
        <xs:attribute name="code"           type="xs:string" use="required" />
        <xs:attribute name="authenticator"  type="xs:string" />
    </xs:complexType>

<!--                                                                                         avp -->
    <xs:complexType name="avpRadiusType">
        <xs:sequence minOccurs="0" maxOccurs="unbounded">
            <xs:element name="avp"  type="vendorAvp"  minOccurs="0" maxOccurs="unbounded" />
            <xs:element name="data"  type="vendorData"  minOccurs="0" maxOccurs="unbounded" />
        </xs:sequence>
        <xs:attribute name="code"           type="xs:string" use="required" />
        <xs:attribute name="value"          type="xs:string" use="required" />
        <xs:attribute name="type"           type="xs:string" />
    </xs:complexType>

    <xs:complexType name="vendorAvp">
        <xs:attribute name="code"         type="xs:string" use="required" />
        <xs:attribute name="value"        type="xs:string" use="required" />
        <xs:attribute name="type"         type="xs:string" />
    </xs:complexType>

    <xs:complexType name="vendorData">
        <xs:attribute name="value"        type="xs:string" use="required" />
    </xs:complexType>

    <!--&type_operations_10;-->
    <!--                                                                      BEGIN OF SMTP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelSMTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="remoteHost" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute> 
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The channel transport.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelSMTPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpoint -->
        <xs:complexType name="createListenpointSMTPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>             
                    <xs:attribute name="listenUDP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenTCP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenTLS" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="transport" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                            <xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

<!--                                                                         removeListenpoint -->
        <xs:complexType name="removeListenpointSMTPType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

<!--                                                                          sendMessage -->
        <xs:complexType name="sendMessageSMTPType">
            <xs:simpleContent>
                <xs:extension base="operationTypeSimple">
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="destScenario" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (scenario name)</xs:appinfo>
                            <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="delay" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="transactionId"  type="xs:string">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>

<!--                                                                         receiveMessage -->
        <xs:complexType name="receiveMessageSMTPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="request" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="type" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="result" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="timeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--&type_operations_11;-->
<!--                                                                       START OF RTSP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelRTSPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="remoteHost" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute> 
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The channel transport.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelRTSPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              createListenpoint -->
    <xs:complexType name="createListenpointRTSPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="listenUDP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTCP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              removeListenpoint -->
    <xs:complexType name="removeListenpointRTSPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              sendMessage -->
    <xs:complexType name="sendMessageRTSPType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="destScenario" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (scenario name)</xs:appinfo>
                        <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="delay" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transactionId"  type="xs:string">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                           receiveMessage -->
    <xs:complexType name="receiveMessageRTSPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="result" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--&type_operations_12;-->
<!--                                                                      BEGIN OF IMAP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelIMAPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="remoteHost" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute> 
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
                        <xs:documentation>The channel transport.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelIMAPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpoint -->
    <xs:complexType name="createListenpointIMAPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="listenUDP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTCP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
                        <xs:documentation>The default transport used to transport messages (in case the transport is not specified int the message content). The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpoint -->
    <xs:complexType name="removeListenpointIMAPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessage -->
    <xs:complexType name="sendMessageIMAPType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple" >                     
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="destScenario" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (scenario name)</xs:appinfo>
                        <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="delay" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>            
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessageIMAPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>     
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="result" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--&type_operations_13;-->
<!--                                                                      BEGIN OF POP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelPOPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="remoteHost" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute> 
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The channel transport.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelPOPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpoint -->
    <xs:complexType name="createListenpointPOPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="listenUDP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTCP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpoint -->
    <xs:complexType name="removeListenpointPOPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessage -->
    <xs:complexType name="sendMessagePOPType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple" >                     
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="destScenario" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (scenario name)</xs:appinfo>
                        <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="delay" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transactionId"  type="xs:string">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>            
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessagePOPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>     
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="result" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--&type_operations_14;-->
    <!--                                                                      BEGIN OF SMPP PROTOCOL -->

<!--                                                                          openChannelSMPP -->
    <xs:complexType name="openChannelSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="remoteHost" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute> 
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The channel transport.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannelSMPP -->
    <xs:complexType name="closeChannelSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpointSMPP -->
    <xs:complexType name="createListenpointSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="listenUDP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTCP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpointSMPP -->
    <xs:complexType name="removeListenpointSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessageSMPP -->
    <xs:complexType name="sendMessageSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence>
                    <xs:element name="header"  	  type="headerSMPPType"      minOccurs="1" maxOccurs="1"/>
                    <xs:element name="attribute"  type="attributeSMPPType"   minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="tlv"        type="tlvSMPPType"         minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="destScenario" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (scenario name)</xs:appinfo>
                        <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="delay" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>            
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessageSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>     
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="result" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                 header -->
    <xs:complexType name="headerSMPPType">
        <xs:attribute name="name"            type="xs:string" />
        <xs:attribute name="id"              type="xs:string" />
        <xs:attribute name="length"          type="xs:string" />
        <xs:attribute name="status"          type="xs:string" />
        <xs:attribute name="sequence_number" type="xs:string" use="required" />
    </xs:complexType>

<!--                                                                                attribute -->
    <xs:complexType name="attributeSMPPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence>
                    <xs:element name="attribute"  type="attributeSMPPType"   minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
                <xs:attribute name="value"      type="xs:string"/>
                <xs:attribute name="type"       type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                     tlv -->
    <xs:complexType name="tlvSMPPType">
        <xs:attribute name="name"       type="xs:string" use="required" />
        <xs:attribute name="length"     type="xs:string" use="required" />
        <xs:attribute name="value"      type="xs:string" use="required" />
        <xs:attribute name="type"       type="xs:string"/>
    </xs:complexType>

    <!--&type_operations_15;-->
<!--                                                                      BEGIN OF UCP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelUCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="remoteHost" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute> 
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The channel transport.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>            
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelUCPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpoint -->
    <xs:complexType name="createListenpointUCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="listenUDP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTCP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpoint -->
    <xs:complexType name="removeListenpointUCPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessage -->
    <xs:complexType name="sendMessageUCPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence>
                    <xs:element name="header"  	  type="headerUCPType"      minOccurs="1" maxOccurs="1"/>
                    <xs:element name="attribute"  type="attributeUCPType"   minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="destScenario" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (scenario name)</xs:appinfo>
                        <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="delay" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transactionId"  type="xs:string">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>            
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessageUCPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>     
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="result" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                 header -->
    <xs:complexType name="headerUCPType">
        <xs:attribute name="name"      type="xs:string" />
        <xs:attribute name="OT"        type="xs:string" />
        <xs:attribute name="LEN"       type="xs:string" />
        <xs:attribute name="TRN"       type="xs:string" use="required"/>
        <xs:attribute name="MT"        type="xs:string" use="required"/>
    </xs:complexType>



<!--                                                                                attribute -->
    <xs:complexType name="attributeUCPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence>
                    <xs:element name="attribute"  type="attributeUCPType"   minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="xser"       type="xserUCPType"        minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
                <xs:attribute name="value"        type="xs:string" />
                <xs:attribute name="encoding"     type="xs:string" />
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                xser -->
    <xs:complexType name="xserUCPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:attribute name="type"    type="xs:string" use="required" />
                <xs:attribute name="length"  type="xs:string" use="required" />
                <xs:attribute name="value"   type="xs:string" use="required" />
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--&type_operations_16;-->
<!--                                                                       START OF PROTOCOL -->

        <!--                                                                          openChannelSIGTRAN -->
        <xs:complexType name="openChannelSIGTRANType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>             
                    <xs:attribute name="remoteHost" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remotePort" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute> 
                    <xs:attribute name="transport" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                            <xs:documentation>The channel transport.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
        <!--                                                                         closeChannelSIGTRAN -->
        <xs:complexType name="closeChannelSIGTRANType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>
        <!--                                                                          createListenpointSIGTRAN -->
        <xs:complexType name="createListenpointSIGTRANType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>             
                    <xs:attribute name="listenUDP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenTCP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenTLS" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="transport" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                            <xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
        <!--                                                                         removeListenpointSIGTRAN -->
        <xs:complexType name="removeListenpointSIGTRANType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>
        <!--                                                                          sendMessageSIGTRAN (protocol binary) -->
        <xs:complexType name="sendMessageSIGTRANType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence>
                        <xs:element name="ASN"  type="APType" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element name="ISDN"  type="ISDNType" minOccurs="0" maxOccurs="1"/>
                        <xs:element name="SS7"  type="SS7Type" minOccurs="0" maxOccurs="unbounded"/>
                        <xs:element name="UA"  type="UAType" minOccurs="1" maxOccurs="1"/>
                    </xs:sequence>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remotePort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="transport" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                            <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="destScenario" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (scenario name)</xs:appinfo>
                            <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="delay" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
        <!--                                                                         receiveMessageSIGTRAN -->
        <xs:complexType name="receiveMessageSIGTRANType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="request" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="type" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="result" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="timeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (SIGTRAN.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                                         	ISDN -->
        <xs:complexType name="ISDNType" mixed="true">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="header"  type="headerISDNType" minOccurs="1" maxOccurs="1" />
                <xs:element name="element"  type="elementISDNType" minOccurs="0" maxOccurs="unbounded" />
            </xs:sequence>
            <xs:attribute name="name" type="xs:string">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The name of the protocol layer.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="syntax" type="xs:string">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The file which describes the syntax grammar of the message data (like dictionary); please give the file path relative to the &lt;install_dir&gt;/conf/sigtran directory.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:complexType>
        <!--                                                                                    element ISDN -->
        <xs:complexType name="elementISDNType">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="field"  type="fieldISDNType" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="identifier"  type="xs:string" />
            <xs:attribute name="coding"  type="xs:string" />
        </xs:complexType>
        <!--                                                                                    field ISDN -->
        <xs:complexType name="fieldISDNType">
            <xs:attribute name="name"  type="xs:string" />
            <xs:attribute name="lengthBit" type="xs:string" />
            <xs:attribute name="type"  type="xs:string" />
            <xs:attribute name="value"  type="xs:string" />
        </xs:complexType>
        <!--                                                                                     headerISDN -->
        <xs:complexType name="headerISDNType">
            <xs:attribute name="discriminator"  type="xs:string" />
            <xs:attribute name="callReference" type="xs:string"/>
            <xs:attribute name="callRefFlag"  type="xs:string" />
            <xs:attribute name="layer3Address" type="xs:string"/>    		
            <xs:attribute name="type"  type="xs:string" />
        </xs:complexType>

        <!--                                                                                         	UA -->
        <xs:complexType name="UAType">
            <xs:sequence>
                <xs:element name="header"           type="headerUAType"/>
                <xs:element name="parameter"        type="parameterUAType"  minOccurs="0" maxOccurs="unbounded" />
            </xs:sequence>
            <xs:attribute name="name"             type="xs:string" />
            <xs:attribute name="file"             type="xs:string" />
        </xs:complexType>
        <!--                                                                                         	header UA -->
        <xs:complexType name="headerUAType">
            <xs:attribute name="version"            type="xs:string" />
            <xs:attribute name="reserved"           type="xs:string" />
            <xs:attribute name="messageClass"       type="xs:string" use="required" />
            <xs:attribute name="messageType"        type="xs:string" use="required" />
            <xs:attribute name="messageLength"      type="xs:string" />
        </xs:complexType>
        <!--                                                                                     parameterUA -->
        <xs:complexType name="parameterUAType">
            <xs:sequence>
                <xs:choice >
                    <xs:element name="parameter"    type="parameterUAType"  minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="field"        type="fieldUAType"      minOccurs="0" maxOccurs="unbounded" />
                </xs:choice >
            </xs:sequence>
            <xs:attribute name="tag"                type="xs:string" use="required" />
            <xs:attribute name="length"             type="xs:string" />
            <xs:attribute name="format"             type="xs:string" />
            <xs:attribute name="value"              type="xs:string" />
        </xs:complexType>
        <!--                                                                                    fieldUA -->
        <xs:complexType name="fieldUAType">
            <xs:attribute name="name"               type="xs:string" />
            <xs:attribute name="start"              type="xs:string" />
            <xs:attribute name="length"             type="xs:string" />
            <xs:attribute name="startBit"           type="xs:string" />
            <xs:attribute name="lengthBit"          type="xs:string" />
            <xs:attribute name="value"              type="xs:string"  />
            <xs:attribute name="format"             type="xs:string" />
        </xs:complexType>

        <!--                                                                                 		SS7 -->
        <xs:complexType name="SS7Type">
            <xs:sequence minOccurs="1" maxOccurs="1">
                <xs:element name="header"			type="parameterSS7Type"	  	minOccurs="0" maxOccurs="1"/>
                <xs:element name="parameter"        type="parameterSS7Type"  	minOccurs="0" maxOccurs="unbounded" />
            </xs:sequence>
            <xs:attribute name="name"             type="xs:string" />
            <xs:attribute name="file"             type="xs:string" />
        </xs:complexType>
        <!--                                                                             		parameterSS7 -->
        <xs:complexType name="parameterSS7Type">
            <xs:sequence>
                <xs:element name="field"        	  type="fieldSS7Type"      		minOccurs="0" maxOccurs="unbounded" />
            </xs:sequence>
            <xs:attribute name="name"               type="xs:string" />
            <xs:attribute name="littleEndian"               type="xs:string" />
            <xs:attribute name="id"                 type="xs:string" />
            <xs:attribute name="lengthIndicatorLength"    type="xs:string" />
            <xs:attribute name="pointerLength"      type="xs:string" />
            <xs:attribute name="type"      		  type="xs:string" />
        </xs:complexType>
        <!--                                                                          		fieldSS7 -->
        <xs:complexType name="fieldSS7Type">
            <xs:attribute name="name"               type="xs:string" />
            <xs:attribute name="start"              type="xs:string" />
            <xs:attribute name="length"             type="xs:string" />
            <xs:attribute name="startBit"           type="xs:string" />
            <xs:attribute name="lengthBit"          type="xs:string" />
            <xs:attribute name="value"              type="xs:string" use="required" />
            <xs:attribute name="format"          	  type="xs:string" />
        </xs:complexType> 

        <!--                                                                                       AP -->
        <xs:complexType name="APType">
            <xs:sequence>
                <xs:any processContents="skip" minOccurs="0" maxOccurs="unbounded"/>
            </xs:sequence>
            <xs:attribute name="dictionary" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The name of the file to be used as dictionary.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:anyAttribute/>
        </xs:complexType>

        <!--&type_operations_17;-->
<!--                                                                      BEGIN OF TLS PROTOCOL -->

<!--                                                                          openChannel -->
        <xs:complexType name="openChannelTLSType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>             
                    <xs:attribute name="remoteHost" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remotePort" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute> 
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                         closeChannelTLS -->
        <xs:complexType name="closeChannelTLSType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

<!--                                                                          createListenpoint -->
        <xs:complexType name="createListenpointTLSType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
<!--                                                                         removeListenpoint -->
        <xs:complexType name="removeListenpointTLSType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                          sendMessage -->
        <xs:complexType name="sendMessageTLSType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence>
                        <xs:element name="data" type="dataTypeTLS" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="destScenario" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (scenario name)</xs:appinfo>
                            <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="delay" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                         receiveMessage -->
        <xs:complexType name="receiveMessageTLSType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="request" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="type" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="result" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>								
                    <xs:attribute name="timeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

<!--                                                                                       data -->
    <xs:complexType name="dataTypeTLS">
        <xs:simpleContent>
            <xs:extension base="xs:string">
                <xs:attribute name="format"       type="dataTypeTypeTLS" />
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                                   dataTypeTLS -->
    <xs:simpleType name="dataTypeTypeTLS">
        <xs:restriction base="xs:string">
            <xs:enumeration value="text" />
            <xs:enumeration value="binary" />
        </xs:restriction>
    </xs:simpleType>

    <!--&type_operations_18;-->
<!--                                                                      BEGIN OF H248 PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelH248Type">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="remoteHost" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute> 
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
                        <xs:documentation>The channel transport.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelH248Type">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpoint -->
    <xs:complexType name="createListenpointH248Type">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="listenUDP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTCP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
                        <xs:documentation>The default transport used to transport messages (in case the transport is not specified int the message content). The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpoint -->
    <xs:complexType name="removeListenpointH248Type">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessage -->
    <xs:complexType name="sendMessageH248Type">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple" >              
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>                             
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS, RFC)</xs:appinfo>
                        <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="destScenario" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (scenario name)</xs:appinfo>
                        <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="delay" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>            
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessageH248Type">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>     
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="result" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--&type_operations_19;-->
<!--                                                                       START OF PCP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelPCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="remoteHost" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute> 
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The channel transport.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="infranetConnection" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The url of the server th user want to connect to.(see pcp.properties for details)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="loginType" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The type of login the user want to use.(see pcp.properties for details)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelPCPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              createListenpoint -->
    <xs:complexType name="createListenpointPCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="listenUDP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTCP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              removeListenpoint -->
    <xs:complexType name="removeListenpointPCPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              sendMessage -->
    <xs:complexType name="sendMessagePCPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:sequence minOccurs="1" maxOccurs="1">
                    <xs:element name="flist"     type="xs:anyType"/>
                </xs:sequence>
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="destScenario" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (scenario name)</xs:appinfo>
                        <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="delay" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transactionId"  type="xs:string">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                           receiveMessage -->
    <xs:complexType name="receiveMessagePCPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="result" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--&type_operations_20;-->
<!--                                                                       START OF MSRP PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelMSRPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="remoteHost" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute> 
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
                        <xs:documentation>The channel transport.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelMSRPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              createListenpoint -->
    <xs:complexType name="createListenpointMSRPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="listenTCP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
                        <xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              removeListenpoint -->
    <xs:complexType name="removeListenpointMSRPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                              sendMessage -->
    <xs:complexType name="sendMessageMSRPType">
        <xs:simpleContent>
            <xs:extension base="operationTypeSimple">
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (TCP, TLS)</xs:appinfo>
                        <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="destScenario" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (scenario name)</xs:appinfo>
                        <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="delay" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transactionId"  type="xs:string">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The transaction ID value to associate a response with an already received request. (useful for response only)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:simpleContent>
    </xs:complexType>

<!--                                                                           receiveMessage -->
    <xs:complexType name="receiveMessageMSRPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="result" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--&type_operations_21;-->
<!--                                                                      BEGIN OF GTPP PROTOCOL -->

<!--                                                                          openChannelGTPP -->
    <xs:complexType name="openChannelGTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="remoteHost" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel remote host (sometimes called the destination host). It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="required">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel remote port (sometimes called the remote port).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute> 
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The channel transport.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannelGTPP -->
    <xs:complexType name="closeChannelGTPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          createListenpointGTPP -->
    <xs:complexType name="createListenpointGTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="listenUDP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTCP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpointGTPP -->
    <xs:complexType name="removeListenpointGTPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessageGTPP -->
    <xs:complexType name="sendMessageGTPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence>
                    <xs:element name="headerPrime" type="headerGTPPrimeType" minOccurs="0" maxOccurs="1"/>
                    <xs:element name="headerV1"  	 type="headerGTPV1Type"    minOccurs="0" maxOccurs="1"/>
                    <xs:element name="headerV2"  	 type="headerGTPV2Type"    minOccurs="0" maxOccurs="1"/>
                    <xs:element name="header "   	 type="headerGTPType"      minOccurs="0" maxOccurs="1"/>  
                    <xs:element name="element"     type="elementGTPType"     minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="pdu"     type="pduGTPType"     minOccurs="0" maxOccurs="unbounded" />                  
                </xs:sequence>
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="destScenario" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (scenario name)</xs:appinfo>
                        <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="delay" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>            
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessageGTPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>     
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="result" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="createProbeGTPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="networkInterface" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="captureFilter" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="filename" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The filename to capture the network packets.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="regexFilter" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="promiscuousMode" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <xs:complexType name="removeProbeGTPType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                          GTPP (PRIME) header -->
    <xs:complexType name="headerGTPPrimeType">
        <xs:attribute name="version" type="xs:string" />
        <xs:attribute name="protocolType" type="xs:string"/>
        <xs:attribute name="length" type="xs:string" />
        <xs:attribute name="type" type="xs:string" use="required"/>
        <xs:attribute name="sequenceNumber" type="xs:string" use="required" />
    </xs:complexType>

    <!--                                                                            GTP V1 Header -->    
    <xs:complexType name="headerGTPV1Type">
        <xs:attribute name="version" type="xs:string"/>
        <xs:attribute name="protocolType" type="xs:string"/>
        <xs:attribute name="extensionHeaderFlag" type="xs:string" />
        <xs:attribute name="sequenceNumberFlag" type="xs:string" />
        <xs:attribute name="nPduNumberFlag" type="xs:string" />
        <xs:attribute name="length" type="xs:string" />
        <xs:attribute name="type" type="xs:string" use="required"/>
        <xs:attribute name="tunnelEndpointId" type="xs:string" use="required"/>
        <xs:attribute name="sequenceNumber" type="xs:string" />
        <xs:attribute name="nPduNumber" type="xs:string" />
        <xs:attribute name="nextExtensionType" type="xs:string" />
    </xs:complexType>

    <!--                                                                            GTP V2 Header -->    
    <xs:complexType name="headerGTPV2Type">
        <xs:attribute name="version"	type="xs:string" />
        <xs:attribute name="piggyFlag"	type="xs:string" />
        <xs:attribute name="teidFlag"	type="xs:string" />
        <xs:attribute name="length" type="xs:string" />
        <xs:attribute name="type" type="xs:string" use="required"/>
        <xs:attribute name="tunnelEndpointId" type="xs:string" />
        <xs:attribute name="sequenceNumber" type="xs:string" use="required"/>
        <xs:attribute name="spare" type="xs:string"/>
    </xs:complexType>

    <xs:complexType name="headerGTPType">
        <xs:attribute name="discriminator" type="xs:string" />
        <xs:attribute name="layer3Address" type="xs:string" />
        <xs:attribute name="type" type="xs:string" />
    </xs:complexType>

<!--                                                                                     element -->
    <xs:complexType name="elementGTPType">
        <xs:sequence>
            <xs:element name="field"  	  type="fieldGTPType"  minOccurs="0" maxOccurs="unbounded"/>
            <xs:element name="element"  	type="elementGTPType"  minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="tag" type="xs:string" />
        <xs:attribute name="name" type="xs:string" />     
        <xs:attribute name="instances" type="xs:string" />
        <xs:attribute name="coding"     type="xs:string" />
        <xs:attribute name="description"  type="xs:string" />        
    </xs:complexType>

<!--                                                                                     field -->
          <xs:complexType name="fieldGTPType">
              <xs:sequence minOccurs="0" maxOccurs="unbounded">
                  <xs:element name="field"  type="fieldISDNType" minOccurs="0" maxOccurs="unbounded"/>
              </xs:sequence>
              <xs:attribute name="name"  type="xs:string" />
              <xs:attribute name="lengthBit" type="xs:string" />
              <xs:attribute name="type"  type="xs:string" />
              <xs:attribute name="value"  type="xs:string" />
              <xs:attribute name="description"  type="xs:string" />
          </xs:complexType>

          <xs:complexType name="pduGTPType">
              <xs:simpleContent>
                  <xs:extension base="xs:string">
                      <xs:attribute name="format"       type="pduGTPFormatType" />
                  </xs:extension>
              </xs:simpleContent>
          </xs:complexType>

          <xs:simpleType name="pduGTPFormatType">
              <xs:restriction base="xs:string">
                  <xs:enumeration value="text" />
                  <xs:enumeration value="binary" />
              </xs:restriction>
          </xs:simpleType>

          <!--&type_operations_22;-->
<!--                                                                      BEGIN OF SNMP PROTOCOL -->

<!--                                                                          createListenpointSNMP -->
    <xs:complexType name="createListenpointSNMPType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="listenUDP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTCP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The default transport when the listenpoint is used to send message. The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         removeListenpointSNMP -->
    <xs:complexType name="removeListenpointSNMPType">
        <xs:complexContent>
            <xs:extension base="operationType" />
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                sendMessageSNMP -->
    <xs:complexType name="sendMessageSNMPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence>
                    <xs:element name="header"  	  type="headerSNMPType"      minOccurs="1" maxOccurs="1"/>
                    <xs:element name="pdu"        type="pduSNMPType"         minOccurs="1" maxOccurs="1" />
                </xs:sequence>
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the channel to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="destScenario" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (scenario name)</xs:appinfo>
                        <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="delay" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>            
        </xs:complexContent>
    </xs:complexType>

<!--                                                                             receiveMessage -->
    <xs:complexType name="receiveMessageSNMPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:sequence minOccurs="0" maxOccurs="unbounded">
                    <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                </xs:sequence>     
                <xs:attribute name="channel" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="listenpoint" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="request" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="type" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="result" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="timeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Float</xs:appinfo>
                        <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                                 header -->
    <xs:complexType name="headerSNMPType">
        <xs:attribute name="version"            type="xs:string" use="required"/>
        <xs:attribute name="community"            type="xs:string" use="required"/>
    </xs:complexType>

<!--                                                                                     pdu -->
    <xs:complexType name="pduSNMPType">
        <xs:sequence>
            <xs:element name="variableBinding"  	  type="variableBindingSNMPType"  minOccurs="0" maxOccurs="unbounded"/>
        </xs:sequence>
        <xs:attribute name="name"                type="xs:string" />
        <xs:attribute name="type"                type="xs:string"/>
        <xs:attribute name="requestId"           type="xs:string" />
        <xs:attribute name="errorStatus"         type="xs:string"/>
        <xs:attribute name="errorIndex"          type="xs:string"/>
        <xs:attribute name="nonRepeaters"        type="xs:string"/>
        <xs:attribute name="maxRepetitions"      type="xs:string"/>
        <xs:attribute name="enterprise"          type="xs:string"/>
        <xs:attribute name="agentAddress"        type="xs:string"/>
        <xs:attribute name="genericTrap"         type="xs:string"/>
        <xs:attribute name="specificTrap"        type="xs:string"/>
        <xs:attribute name="timestamp"           type="xs:string"/>
    </xs:complexType>

<!--                                                                                variableBinding -->
    <xs:complexType name="variableBindingSNMPType">
        <xs:complexContent>
            <xs:extension base="operationType" >
                <xs:attribute name="value"      type="xs:string"/>
                <xs:attribute name="type"       type="xs:string"/>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

    <!--&type_operations_23;-->
<!--                                                                       START OF MGCP PROTOCOL -->

        <!--                                                                          createListenpoint -->
        <xs:complexType name="createListenpointMGCPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>             
                    <xs:attribute name="listenUDP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenTCP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenTLS" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="transport" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS, RFC)</xs:appinfo>
                            <xs:documentation>The default transport used to transport messages (in case the transport is not specified int the message content). The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
        <!--                                                                         removeListenpoint -->
        <xs:complexType name="removeListenpointMGCPType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                          createProbe -->
        <xs:complexType name="createProbeMGCPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="networkInterface" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="captureFilter" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="filename" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The filename to capture the network packets.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="regexFilter" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="promiscuousMode" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
        <!--                                                                         removeProbe -->
        <xs:complexType name="removeProbeMGCPType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                          sendMessage -->
        <xs:complexType name="sendMessageMGCPType">
            <xs:simpleContent>
                <xs:extension base="operationTypeSimple">
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remotePort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="transport" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS, RFC)</xs:appinfo>
                            <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="destScenario" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (scenario name)</xs:appinfo>
                            <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="delay" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
        <!--                                                                         receiveMessage -->
        <xs:complexType name="receiveMessageMGCPType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="request" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="type" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="result" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="timeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--&type_operations_24;-->
        <!--                                                                       START OF STUN PROTOCOL -->

        <!--                                                                          createListenpoint -->
        <xs:complexType name="createListenpointSTUNType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="localHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint local host i.e. the IP address we are listening to. It should of course be one of the local addresses of the host or a host name with a DNS resolution. The default value is configurable(ppp.properties/listenpoint.LOCAL_HOST)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port i.e. the port we are listening to. The default value is configurable(ppp.properties/listenpoint.LOCAL_PORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The listenpoint local URL we are listening to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>             
                    <xs:attribute name="listenUDP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the UDP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_UDP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenTCP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the TCP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TCP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenSCTP" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the SCTP transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_SCTP)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenTLS" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>A flag to specify whether we are listening to the TLS transport. The default value is configurable(ppp.properties/listenpoint.LISTEN_TLS)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="localPortTLS" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The listenpoint local port for TLS transport i.e. the port we are listening to. The default value is LOCAL_PORT + 1</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="transport" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS, RFC)</xs:appinfo>
                            <xs:documentation>The default transport used to transport messages (in case the transport is not specified int the message content). The default value is configurable(ppp.properties/listenpoint.TRANSPORT)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
        <!--                                                                         removeListenpoint -->
        <xs:complexType name="removeListenpointSTUNType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                          createProbe -->
        <xs:complexType name="createProbeSTUNType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="networkInterface" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="captureFilter" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="filename" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The filename to capture the network packets.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="regexFilter" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="promiscuousMode" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>
        <!--                                                                         removeProbe -->
        <xs:complexType name="removeProbeSTUNType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <!--                                                                          sendMessage -->
        <xs:complexType name="sendMessageSTUNType">
            <xs:complexContent>
                <!--<xs:extension base="operationTypeSimple">-->
                    <xs:extension base="operationType">
                        <xs:sequence>
                            <xs:element name="header"  type="headerSTUNType" />
                            <xs:element name="attribute"  type="attributeSTUNType"       minOccurs="0" maxOccurs="unbounded" />
                        </xs:sequence>
                        <xs:attribute name="listenpoint" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>String</xs:appinfo>
                                <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="remoteHost" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>String</xs:appinfo>
                                <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="remotePort" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>Integer</xs:appinfo>
                                <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="remoteURL" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>String (url)</xs:appinfo>
                                <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="transport" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                                <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="destScenario" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>String (scenario name)</xs:appinfo>
                                <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="delay" type="xs:string" use="optional">
                            <xs:annotation>
                                <xs:appinfo>Float</xs:appinfo>
                                <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                        <xs:attribute name="request"      type="xs:string" >
                            <xs:annotation>
                                <xs:appinfo>Boolean</xs:appinfo>
                                <xs:documentation>The flag to indicate whether the message is a request ("True") or a response ("false").</xs:documentation>
                            </xs:annotation>
                        </xs:attribute>
                    </xs:extension>
                </xs:complexContent>
            </xs:complexType>


            <xs:complexType name="headerSTUNType">
                <xs:attribute name="type"  type="xs:string" />
                <xs:attribute name="transactionID" type="xs:string"  />

            </xs:complexType>

<!--                                                                                         avp -->
<xs:complexType name="attributeSTUNType">
    <xs:sequence minOccurs="0" maxOccurs="unbounded">
        <xs:element name="address"  type="addressType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="changeRequest"  type="changeRequestType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="errorCode"  type="errorCodeType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="binary"  type="binaryType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="text"  type="textType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="messageIntegrity"  type="messageIntegrityType" minOccurs="0" maxOccurs="unbounded"/>
        <xs:element name="unknownAttribute"  type="unknownAttributeType" minOccurs="0" maxOccurs="unbounded"/>
    </xs:sequence>
    <xs:attribute name="type" type="xs:string" />
</xs:complexType>

<xs:complexType name="addressType">
    <xs:attribute name="family"  type="xs:string" />
    <xs:attribute name="port" type="xs:string"/>
    <xs:attribute name="addressIP"  type="xs:string" />
</xs:complexType>

<xs:complexType name="changeRequestType">
    <xs:attribute name="changeIP"  type="xs:string" />
    <xs:attribute name="changePort" type="xs:string" />
</xs:complexType>

<xs:complexType name="errorCodeType">
    <xs:attribute name="code"  type="xs:string" />
    <xs:attribute name="reasonPhrase" type="xs:string" />
</xs:complexType>

<xs:complexType name="binaryType">
    <xs:attribute name="value"  type="xs:string" />
</xs:complexType>

<xs:complexType name="textType">
    <xs:attribute name="value"  type="xs:string" />

</xs:complexType>

<xs:complexType name="messageIntegrityType">
    <xs:attribute name="value"  type="xs:string" />
    <xs:attribute name="secret"  type="xs:string" use="required"/>
</xs:complexType>

<xs:complexType name="unknownAttributeType">
    <xs:attribute name="type"  type="xs:string" />
</xs:complexType>

<!--                                                                         receiveMessage -->
<xs:complexType name="receiveMessageSTUNType">
    <xs:complexContent>
        <xs:extension base="operationType">
            <xs:sequence minOccurs="0" maxOccurs="unbounded">
                <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
            </xs:sequence>
            <xs:attribute name="channel" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="listenpoint" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="request" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="type" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="result" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>String</xs:appinfo>
                    <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="timeout" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Float</xs:appinfo>
                    <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
            <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                <xs:annotation>
                    <xs:appinfo>Boolean</xs:appinfo>
                    <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                </xs:annotation>
            </xs:attribute>
        </xs:extension>
    </xs:complexContent>
</xs:complexType>

<!--&type_operations_25;-->
<!--                                                                       START OF H225CS PROTOCOL -->

<!--                                                                          openChannel -->
    <xs:complexType name="openChannelH225CSType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="localHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel local host (sometimes called the source host). It should of course be one of the local addresses of the host or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localPort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel local port (sometimes called the source port). The default value is chosen by the tool.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="localURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The local URL of the channel (sometimes called the source information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute>             
                <xs:attribute name="remoteHost" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The channel remote host (sometimes called the destination host) of the channel. It could be an IP address or a host name with a DNS resolution.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="remotePort" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Integer</xs:appinfo>
                        <xs:documentation>The channel remote port (sometimes called the destination port) of the channel.</xs:documentation>
                    </xs:annotation>
                </xs:attribute> 
                <xs:attribute name="remoteURL" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String (url)</xs:appinfo>
                        <xs:documentation>The remote URL of the channel (sometimes called the destination information).</xs:documentation>
                    </xs:annotation>
                </xs:attribute> 
                <xs:attribute name="transport" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                        <xs:documentation>The channel transport.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>            
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>

<!--                                                                         closeChannel -->
    <xs:complexType name="closeChannelH225CSType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

    <!--                                                                          createProbe -->
    <xs:complexType name="createProbeH225CSType">
        <xs:complexContent>
            <xs:extension base="operationType">
                <xs:attribute name="networkInterface" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="captureFilter" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="filename" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The filename to capture the network packets.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="regexFilter" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>String</xs:appinfo>
                        <xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
                <xs:attribute name="promiscuousMode" type="xs:string" use="optional">
                    <xs:annotation>
                        <xs:appinfo>Boolean</xs:appinfo>
                        <xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
                    </xs:annotation>
                </xs:attribute>
            </xs:extension>
        </xs:complexContent>
    </xs:complexType>
    <!--                                                                         removeProbe -->
    <xs:complexType name="removeProbeH225CSType">
        <xs:complexContent>
            <xs:extension base="operationType"/>
        </xs:complexContent>
    </xs:complexType>

    <!--                                                                          sendMessage -->
    <xs:complexType name="sendMessageH225CSType">
        <xs:complexContent>
            <!--<xs:extension base="operationTypeSimple">-->
                <xs:extension base="operationType">
                    <xs:sequence>
                        <xs:element name="ASN1"  type="asn1Type" minOccurs="0" maxOccurs="1"/>
                        <xs:element name="ISDN"  type="ISDNType" minOccurs="1" maxOccurs="1"/>
                    </xs:sequence>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The name of the listenpoint to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteHost" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The remote host to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remotePort" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The remote port to send the message to. Don't use it with the channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="remoteURL" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (url)</xs:appinfo>
                            <xs:documentation>The remote URL to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="transport" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>enumeration (UDP, TCP, SCTP, TLS)</xs:appinfo>
                            <xs:documentation>The protocol transport to send the message to. Don't use it with the channel (incompatible).</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="destScenario" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (scenario name)</xs:appinfo>
                            <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="delay" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="request"      type="xs:string" >
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>The flag to indicate whether the message is a request ("True") or a response ("false").</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <xs:complexType name="asn1Type">
            <xs:sequence>
                <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
            </xs:sequence>
            <xs:attribute name="file"  type="xs:string" />
        </xs:complexType>

<!-- avp -->




        <!-- receiveMessage -->
        <xs:complexType name="receiveMessageH225CSType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                    <xs:attribute name="channel" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The channel name to transport the message. Don't use it with listenpoint (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="listenpoint" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The listenpoint name to transport the message. Don't use it with channel (incompatible)</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="request" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting for a request whereas false means a response. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="type" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="result" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message result (for response only) we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="timeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <!--&type_operations_26;-->
        <xs:complexType name="sendMessageETHERNETType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence>
                        <xs:element name="ethernet" type="headerETHERNETType" minOccurs="1" maxOccurs="1"/>
                        <xs:element name="data" type="dataIPType" minOccurs="0" maxOccurs="unbounded"/>
                    </xs:sequence>
                    <xs:attribute name="probe" type="xs:string" use="required">
                        <xs:annotation>
                            <xs:appinfo>String (scenario name)</xs:appinfo>
                            <xs:documentation>name of the network card interface to bind on</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="destScenario" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String (scenario name)</xs:appinfo>
                            <xs:documentation>The destination scenario if the request commes to IMSloader again (case of proxy testing). This attribute should contain the name of the scenario to route the same message to.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="delay" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The time delay (in seconds) when the message sending is differed.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="length"      	type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Integer</xs:appinfo>
                            <xs:documentation>The length of the message.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <xs:complexType name="receiveMessageETHERNETType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:sequence minOccurs="0" maxOccurs="unbounded">
                        <xs:element name="parameter"  type="parameterType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="test"       type="testType"      minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="and"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="or"         type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                        <xs:element name="not"        type="conditionType" minOccurs="0" maxOccurs="unbounded" />
                    </xs:sequence>
                    <xs:attribute name="timeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Float</xs:appinfo>
                            <xs:documentation>The timeout i.e. the maximum time (in seconds) we are waiting for. The default value is configurable (ppp.properties/operations.RECEIVE_TIMEOUT) If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnReceive" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are not waiting a message i.e. if we will receive a message , then the operation status is set to FAILED. The default value is false.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="failedOnTimeout" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>True means that we are waiting a message i.e. if we won't receive any message , then the operation status is set to FAILED. The default value is true.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="probe" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>Wireshark capture filter</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="type" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The message type we are waiting for. If not specified, then no filtering is required</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>


        <xs:complexType name="createProbeETHERNETType">
            <xs:complexContent>
                <xs:extension base="operationType">
                    <xs:attribute name="networkInterface" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The network interface to capture on. It should of course something like "eth#N" or "lo".</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="captureFilter" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The capturing filter : the syntax of the attribute is the same as tcpdump ou Wireshark tool. If not set, then we will capture all packets without any filtering.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="filename" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The filename to capture the network packets.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="regexFilter" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>String</xs:appinfo>
                            <xs:documentation>The regular expression filter : the syntax of the attribute is the same as Java regular expression. If not set, then we will capture all packets without any specific filtering.</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                    <xs:attribute name="promiscuousMode" type="xs:string" use="optional">
                        <xs:annotation>
                            <xs:appinfo>Boolean</xs:appinfo>
                            <xs:documentation>The promiscuous mode : In promiscuous mode (true), you can capture packets every packet from the wire, i.e., even if its source or destination MAC address is not same as the MAC address of the interface you are opening. In non-promiscuous mode, you can only capture packets send and received by your host. If not set, default value is "true".</xs:documentation>
                        </xs:annotation>
                    </xs:attribute>
                </xs:extension>
            </xs:complexContent>
        </xs:complexType>

        <xs:complexType name="removeProbeETHERNETType">
            <xs:complexContent>
                <xs:extension base="operationType"/>
            </xs:complexContent>
        </xs:complexType>

        <xs:complexType name="headerETHERNETType">
            <xs:simpleContent>
                <xs:extension base="xs:string">
                    <xs:attribute name="remoteMac" type="xs:string" use="required"/>
                    <xs:attribute name="type" type="xs:string" use="required" />
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>

        <xs:complexType name="dataIPType">
            <xs:simpleContent>
                <xs:extension base="xs:string">
                    <xs:attribute name="format"       type="dataIPFormatType" />
                </xs:extension>
            </xs:simpleContent>
        </xs:complexType>
        <xs:simpleType name="dataIPFormatType">
            <xs:restriction base="xs:string">
                <xs:enumeration value="text" />
                <xs:enumeration value="binary" />
            </xs:restriction>
        </xs:simpleType>


    </xs:schema>

